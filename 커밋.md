# 코드의 변화
## 파일 관리방법
깃의 커밋은 새로 변경된 부분만 추출하여 저장한다. 그것도 파일 이름을 변경하지 않고도 동일한 파일 이름으로 하나로 관리가 가능하다.  
시간에 따라 변화되는 내용만 관리하고, 코드가 변화된 시간 순서에 따라서 영구적으로 저장한다. 이를 `커밋(commit)` 이라고 한다.    
커밋은 부모 커밋을 기반으로 변화된 부분만 새로운 커밋으로 생성한다. 그리고 커밋은 파일의 시간적 변화도 함께 저장한다.  

## 새 파일 생성 및 감지 
워킹 디렉터리에 새 파일이 추가되면 깃은 변화된 상태를 자동으로 감지한다.   
이때 깃 상태를 확인할 수 있는 명령어가 `status`이다.  
```python
> git status
현재 브랜치 master
브랜치가 'origin/master'에 맞게 업데이트된 상태입니다.

커밋하도록 정하지 않은 변경 사항:
  (무엇을 커밋할지 바꾸려면 "git add <파일>..."을 사용하십시오)
  (use "git restore <file>..." to discard changes in working directory)
	수정함:        .DS_Store

추적하지 않는 파일:
  (커밋할 사항에 포함하려면 "git add <파일>..."을 사용하십시오)
	커밋.md

커밋할 변경 사항을 추가하지 않았습니다 ("git add" 및/또는 "git commit -a"를
사용하십시오)
```
깃 배시 터미널로 실행하면 추적되지 않은 파일은 빨간색으로 표시한다. **"추적하지 않는 파일"** 메시지는 워킹 디렉터리에 새로운 파일이 등록되었다고 알려 주는 것이다.  
이렇게 깃은 워킹 디렉터리에 새 파일이 추가되면 상태를 감지하고 향후 이력을 추적할지 여부를 결정한다.   

## 깃에 새 파일 등록
워킹 디렉터리에 있는 파일은 깃이 자동으로 추적 관리 하지 않는다. 커밋을 하려면 **파일의 상태가 추적 가능**해야 한다.  

![깃에 새 파일 등록](images/img_6.png)

워킹 디렉터리는 작업을 위한 일종의 **샌드박스(서로 분리되어 있는 영역)** 와 같다.  

### 스테이지에 등록  
깃에서 등록이란 워킹 디렉터리에 있는 파일을 **스테이지(stage) 영역으로 복사**하는 것을 의미한다.  여기서 '복사'는 실제 파일을 복사하는 것을 의미하지 않는다.   
깃 내부에서 논리적인 기록을 변경하는 과정일 뿐이다.  
워킹 디렉터리에 추가된 모든 파일을 커밋할 때는 반드시 이 과정을 거쳐야 한다. 그래야 깃에서 버전 이력을 관리할 수 있다. 스테이지에 등록되지 않은 **unstage 상태의 파일들은 커밋할 수 없다.**  깃은 커밋하기 전에 파일들이 stage 상태인지 unstage 상태인지를 판단한다. 스테이지 영역으로 등록된 파일들은 tracked 상태로 자동 변경 된다. 

### 명령어로 등록 : add 명령어
현재는 커밋 명령어를 실행하기 이전의 중간 단계이다. 깃의 `add 명령어`는 워킹 디렉터리의 파일을 스테이지 영역으로 등록한다.   
깃은 안정적인 커밋을 할 수 있도록 add 명령어를 기준으로 이전과 이후 단계를 구분한다.  

```python
git add "파일명"
```

![git add](images/img_7.png)   

add 명령어를  실행하면 지정한 파일은 스테이지 영역으로 등록된다. 스테이지 영억에 파일이 **등록되면 파일은 tracked 상태로 변경** 된다.  
워킹 디렉터리에서 필요한 파일만 스테이지 영역에 등록하여 이력을 추적하면 된다.  
**스테이지 영역에 등록하지 않은 파일은 커밋 작업에 포함되지 않는다.** 또한 빈 폴더는 스테이지 영역에 등록할 수 없다.

### 파일의 추적 상태 확인
`git status` 명령어를 입력하면 아까와 달리 `새 파일` 메시지가 출력 되는데, 이는 스테이지 영역에 파일을 정상적으로 등록했다는 의미이다.
```python
> git status
현재 브랜치 master
브랜치가 'origin/master'에 맞게 업데이트된 상태입니다.

커밋할 변경 사항:
  (use "git restore --staged <file>..." to unstage)
	수정함:        .DS_Store
	새 파일:       images/img_6.png
	새 파일:       images/img_7.png
	새 파일:       커밋.md
```
### 파일 등록 취소  
이번에는 tracked 상태의 파일을 `untracked 상태`로 변경해보자.  등록 취소는 워킹 디렉터리와 스테이지 영역을 서로 왔다 갔다 할 수 있는 방법이다. 
unstage 상태로 변경하려면 `삭제(rm)`나 `리셋(reset)` 명령어를 사용한다. 

![git reset](images/img_8.png)   
먼저 rm 명령어로 삭제해 보면, 스테이지 영역에서만 등록된 파일을 삭제하려고 `--cached`옵션을 함께 사용한다.
```python
> git rm --cached 커밋.md
rm '커밋.md'
```
git status 를 통해 상태를 확인해보면 untracked로 변경된 것을 알 수 있다.

```python
> git status
현재 브랜치 master
브랜치가 'origin/master'에 맞게 업데이트된 상태입니다.

커밋할 변경 사항:
  (use "git restore --staged <file>..." to unstage)
	수정함:        .DS_Store
	새 파일:       images/img_6.png
	새 파일:       images/img_7.png

추적하지 않는 파일:
  (커밋할 사항에 포함하려면 "git add <파일>..."을 사용하십시오)
	커밋.md
```
파일을 등록한 후 커밋하지 않고 바로 삭제하려면 `rm --cached`명령어를 사용한다. 하지만 **한번이라도 커밋을 했다면 `reset 명령어`를 사용**해야 한다.

커밋 후 삭제는 파일이 **삭제 또는 변화된 것으로 간주**한다. 따라서 커밋된 파일은 리셋으로 삭제한 후 정리해 주어야 한다. 

## 첫 번째 커밋
지금까지 한 작업은 커밋의 준비 작업들이다. 이번에는 스테이지 영역에 등록된 파일들을 커밋해서 기록하는 과정을 알아보자.  
### HEAD
커밋을 학습하기 전에 HEAD 개념을 하나 더 알아보자. 깃에는 `HEAD`라는 **포인터** 개념이 있다. HEAD는 커밋을 가리키는 묵시적 참조 포인터다.  
![first commit](images/img_9.png)   

HEAD는 최종적인 커밋 작업의 위치를 가리킨다. 처음 커밋할 때는. HEAD의 포인터가 없다. 최소한 한 번 이상 커밋을 해야만  HEAD가 존재한다.  

### 스냅샷
커밋은 파일 변화를 깃 저장소에 **영구적**으로 기록한다.  깃이 다른 버전 관리 도구와 다른 점은 `스냅샷`방식을 이용한다는 것이다.   
파일을 복사하는 방식으로 수정본을 관리하면 같은 내용을 반복해서 저장하기에 많은 용량을 차지 한다.    
또 수정된 부분들을 일일이 찾아야 하기 때문에 검색할 때도 매우 불편하다.  
깃은 이러한 시스템적인 단점을 해결하려고 변경된 파일 전체를 저장하지 않고, 파일에서 변경된 부분을 찾아 수정된 내용만 저장한다. 마치 변화된 부분만 찾아서 사진을 찍는 것과 같다고 하여 스냅샷 방식이라고 한다.  

![스냅샷](images/img_10.png)   
깃의 스냅샷은 HEAD가 가리키는 커밋을 기반으로 사진을 찍는다. 그리고 이를 스테이지 영역과 비교하여 새로운 커밋으로 기록한다.  
이처럼 깃은 스냅샷 방식을 이용하여 **빠르게 버전의 차이점을 처리하고, 용량을 적게 사용**한다.


### 파일 상태와 커밋
커밋은 변화된 내용을 영구적으로 깃 저장소에 기록한다. 새롭게 생성된 파일을 커밋하려면 **반드시 tracked 상태로 변경** 해 줘야 한다.